# 堆排序
堆排序是一种就地排序，在任何时候数组中只有常数个元素存储在输入数组之外。  
运行时间：O(nlogn)

在算法中，堆是一种数据结构，它是一颗二叉树，如下图所示：  
![person_pb2](../images/堆1.jpeg)

## 堆排序的基本性质
其中，树的每一层都会被填满，除了最后一层，最后一层会从一个节点的左子树开始填。堆采用数组的方式来存储，如`[16, 14, 10, 8, 7, 9, 3, 2, 4, 1]`。给定数组A，其树的根为A[1]，给定某个节点的下标为i，则左儿子和右儿子的下边可以简单的被计算出来:
1. left：i * 2
2. right：(i * 2) + 1
3. parent：i / 2，向下取整

观察上面的计算公式，我们知道在计算机里，可以通过左移和右移来计算与2的乘法和除法，因此也有了如下公式：
1. left：i的二进制左移1位
1. right：i的二进制左移1位并在低位中+1
1. parent：i的二进制右移1位得到i/2

二叉堆包含两种：最大堆和最小堆。
1. 最大堆：A[parent(i)] >= A[i]
1. 最小堆：A[parent(i)] <= A[i]

**高度为h的堆中，最多和最好的元素个数？**  
最多元素的情况就是左右子节点全部存在，每一层都会基于上一层的节点个数*2：  
1 + 1 * 2 + 1 * 2 * 2 + ... + 1 * 2^(h) = 1 + 2 + 2^2 + ... + 2^h = 2^(h+1) - 1

最少元素的情况就是最后一层一直一个节点，可以退化成求(h-1)高度的最大元素个数+1，即为2^h

**含N个元素的堆的高度为多少？**  
高度为logN，其中log为以2为底

**高度为h，至多有多少个节点？**  
至多有n/(2^(h+1))，向下取整

## 保持堆的性质
考虑这种情况，某个数组A和下标i，在以left[i]和right[i]为根的两颗二叉树都是最大堆，但这个时候A[i]有可能小于其子女，我们要来调整这个树

```javascript
function maxHeapify(arr, i, len = arr.length) {
  arr.unshift(arr[i - 1])

  let right = i * 2 + 1
  let max = i

  while (right < len + 1) {
    if (arr[right] > arr[0]) {
      max = right
    }
    if (arr[right - 1] > arr[max]) {
      max = right - 1
    }
    if (max === i) {
      break
    }

    arr[i] = arr[max]
    i = max
    right = i * 2 + 1
  }

  if (right === len + 1 && arr[0] < arr[right - 1]) {
    arr[i] = arr[right - 1]
    i = right - 1
  }

  arr[i] = arr[0]

  arr.shift()
}
```

我们知道堆的高度为O(logN)，下沉时间顶多为O(logN)，即O(h)，h为堆的高度

## 建堆
建堆是指将数组中的数据最终变成符合堆的特性的顺序，一般采用自底向上的方式来建堆，每次都是在做maxHeapify的过程，建堆的运行时间为O(N)
```javascript
function buildMaxHeap(arr) {
  for (let i = arr.length / 2; i >= 1; i--) {
    maxHeapify(arr, i)
  }
}
```
因为树得最后一层没有子节点，所以我们都会从树的倒数第二层开始递归，即从最后一层的最后一个节点的父节点开始。

## 堆排序算法
当我们需要将乱序的数组进行堆排序时，会分为两步：
1. 建堆
2. 排序

如果是递增排序，可以采用建立最大堆的方式；如果是递减排序，可以采用建立最小堆的方式。

排序过程：
1. 取出第一个元素，将最后一个元素放到堆顶，必然会引起堆结构被破坏，此时开始调整堆结构。
2. 取出此时的对顶元素，和倒数第二个元素交换，再次调整。
3. 不断重复，知道再无元素可以取。此时会构建出一个递增排序的新堆。

简单来说，堆排序是由构建初始堆+交换堆顶元素和末尾元素并重建堆两部分组成。

```javascript
function sortHeap(arr) {
  let len = arr.length
  for (let i = len - 1; i >= 0; i--) {
    const tmp = arr[i]
    arr[i] = arr[0]
    arr[0] = tmp
    len -= 1
    
    maxHeapify(arr, 1, len)
  }
}
```
运行时间：
构建初始堆+堆元素交换 = O(N) + O(swap)  
堆元素交换运行时间=log(N-1) + log(N-2) + ... + log(1) = O(NlogN)

因此运行时间为 = O(N) + O(NlogN) = O(NlogN)

## 优先级队列
优先级队列是一种特殊的队列，它采用堆的方式来组成队列。因此也有最大优先级队列和最小优先级队列，对应最大堆和最小堆。

对于给定的集合，我们给每个元素一定的权重，按照这个权重构建堆，既可以得到优先级队列。

优先级队列可以很容易的实现查找、删除、添加和修改操作，都是基于堆的操作。

当一个优先级队列中的某个几点发生变化时，可以通过下沉或者上浮来调整队列结构，一般采用上浮，因为只需要对比父节点。而如果采用下沉，由于有2个子节点，需要对比两个，相对复杂一些。  
上浮操作，当某个节点的元素变化时，如果比父节点大了，需要重新调整堆结构，只需要不断上浮即可
```javascript
function swim (arr, i) {
  while (i > 1) {
    if (arr[i] < arr[i/2]) break

    exchange(arr, i, i/2)
    i = i / 2
  }
}
```

查找最大元素：查询数组顶端元素，即第一个元素  

删除最大元素：删除数组顶端元素，并将最后一个元素放入顶端，再不断下沉
```javascript
function delMax (arr) {
  // 从数组从第一个元素开始
  const max = arr[1]
  const pqSize = arr.length
  exchange(arr, 1, pqSize)
  maxHeapify(arr, 1)
}
```

插入元素：将元素插入到数组末尾，然后不断上浮
```javascript
function insert (arr, val) {
  arr.push(val)
  arr.unshift(arr[0])
  swim(arr, arr.length)
}
```

## 结论
一个堆的高度为 logN，因此在堆中插入元素和删除最大元素的复杂度都为 logN。

对于堆排序，由于要对 N 个节点进行下沉操作，因此复杂度为 NlogN。

堆排序时一种原地排序，没有利用额外的空间。

现代操作系统很少使用堆排序，因为它无法利用缓存，也就是数组元素很少和相邻的元素进行比较。
