# 索引
索引是在存储引擎层实现的，不同的存储引擎的索引的工作方式也不一样，也不是所有的存储引擎都支持所有类型的索引，即使多个存储引擎支持同一种类型的索引，底层实现方式也可能不一样。

## B-Tree索引
mysql中的索引采用的是B-Tree这种数据结构来存储数据，因此采用索引查找的时候会有最左前缀的限制，即与创建表时定义索引的顺序有关。

```sql
CREATE TABLE People (
  last_name VARCHAR(50) NOT NULL,
  first_name VARCHAR(50) NOT NULL,
  dob DATE NOT NULL,
  gender ENUM('m', 'f') NOT NULL,
  KEY(last_name, first_name, dob)
)
```
上述sql语句指定了一个联合索引（last_name, first_name, dob）。

接下来分情况讨论

### 全值匹配
当你的查询语句中查询条件包含这三个索引字段时，mysql就能使用索引
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name='Cuba' And dob='1991-10-21';
```
该sql能够有效利用mysql索引。

如果把sql稍微改变下
```sql
SELECT * FROM People WHERE first_name='Cuba' And dob='1991-10-21' AND last_name='Allen' ;
```
这里查询条件中索引字段的顺序被调换了位置，是否依旧能够利用索引进行查询呢？  
答案是可以的，mysql中对这种情况有进行优化过。

### 匹配最左前缀
当只使用部分索引字段时，必须按照索引顺序来使用，如下面的sql只使用了第一列：
```sql
SELECT * FROM People WHERE last_name='Allen';
```
也可以使用索引前两列：
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name='Cube';
```

如果查询时没有按照索引的顺序来使用，或者跳过了第一个索引字段，则不满足最左前缀，例如下面的语句都是无法使用索引：
```sql
SELECT * FROM People WHERE first_name='Cuba';
SELECT * FROM People WHERE dob='1991-10-21';
SELECT * FROM People WHERE first_name='Cuba' AND dob='1991-10-21';
SELECT * FROM People WHERE last_name='Allen' AND dob='1991-10-21';
```

### 匹配列前缀
可以只匹配某一列的值的开头部分，例如以`Al`开头的last_name；
```sql
SELECT * FROM People WHERE last_name LIKE 'Al%';
```
但是如果是模糊匹配以`len`结尾则无法使用索引，如下面的sql：
```sql
SELECT * FROM People WHERE last_name LIKE '%len';
```
同最左前缀一样，这里也只能使用第一列进行模糊匹配，如下面这条sql就无法利用first_name的索引。
```sql
SELECT * FROM People WHERE first_name LIKE 'Cu%';
```

### 匹配范围值
例如可以查找last_name在`Allen`和`Mike`的人。
```sql
SELECT * FROM People WHERE last_name='Allen' OR last_name='Mike';
```

### 精确匹配某一列并范围匹配另外一列
查询语句中可以有精确匹配，也可以有模糊匹配
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name LIKE 'Cu%';
```
但是此时，如果还是用了dob作为查询条件，是无法使用dob的索引的。  
换句话说，即如果查询有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name LIKE 'Cu%' AND dob = '1991-10-21';
```

以上列出了几种查询情况能够使用索引的方式，当然这些不仅是在`WHERE`子句中生效，在`ORDER BY`只要满足上述查询方式，索引依旧有效。

## 哈希索引
哈希索引是基于哈希表实现的，只有精确匹配索引所有列的的查询才能有效。存储引擎会对所有索引列计算一个哈希码，它是一个较小的值。然后引擎会维护一个哈希表，key为之前计算的哈希值，value是对应行的指针。

在查找数据时候，先计算列对应的哈希值，通过哈希表找到行指针，还要对比行指针中列的数据是否是之前指定的数据。

在mysql中，只有Memory引擎显示支持哈希索引，也是它的默认索引，但是它也支持b-tree索引。  
另外，Memory引擎支持非唯一哈希索引，如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。

```sql
CREATE TABLE testhash (
  fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  KEY USING HASH(fname) 
) ENGINE=MEMORY
```
网数据库中插入几条测试数据

fname | lname 
---------|----------
 A1 | B1 
 A2 | B2 
 A3 | B3 
 A4 | B4

引擎中的哈希函数，假设为hash()，可能会有如下值返回
```
hash('A1') = 2323
hash('A2') = 7437
hash('A3') = 8784
hash('A4') = 2458
hash('A5') = 2458
```

这时哈希引擎维护了如下这样一张哈希表：

槽（slot） | 值（value）
---------|----------
 2323 | 指向第1行的指针
 2458 | 指向第4行的指针 --> 指向第5行的指针
 7437 | 指向第2行的指针
 8784 | 指向第3行的指针

这时如果你的sql如下
```sql
SELECT * FROM testhash WHERE fname='A3';
```
这时将fname哈希后值为8784，通过哈希表知道它`指向第3行的指针`，故能快速定位到表的第3行中，这个是常数时间。

虽然哈希索引很快，但是也有一些弊端
1. 由于采用的是将索引字段哈希，故无法用于排序
2. 哈希索引只包含哈希值和行指针，而不存储字段值，无法使用索引中的值来避免读取行
3. 哈希索引不支持部分索引匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希。因此如果在数据列(A,B)上建立哈希索引，如果只查询数据列A，则无法使用该索引。
4. 哈希索引只支持等值比较查询
5. 当出现哈希值冲突时，底层采用了链表来存储所有的行指针，此时需要逐个遍历行指针。例如上面示例中A5的哈希值和A4一样，则哈希表会维护一个链表，遍历后能够知道A5在第5行。
6. 哈希冲突很多的话，对数据的删除很不利。因为每次删除数据，需要逐个遍历链表找到对应的行，删除对应行的引用。

鉴于以上弊端，我们很少直接使用哈希索引。如果我们既想使用哈希索引高效的查找速度，也想拥有B-Tree索引的特性（如：排序、部分列查找）该怎么办。这时我们可以在B-Tree基础上创建一个伪哈希索引

### B-Tree和哈希索引结合
有这样一个场景，假设我们经常需要通过一个url来查询，而由于url本身很长，索引存储的内容很大，性能上会不大好，如果我们增加一个url_crc的列，它是个整型值，值来自于url的crc32值，由于crc32的值都会比较短，性能上能够得到提高。

```sql
CREATE TABLE btreehash (
  id INT UNSIGNED NOT NULL auto_increment,
  url VARCHAR(255) NOT NULL,
  url_crc INT UNSIGNED NOT NULL DEFAULT 0,
  PRIMARY KEY(id)
)
```

接下来创建一个触发器，在每次写入和更新的时候都自动计算url_crc值
```SQL
DELIMITER //

CREATE TRIGGER btreehash_crc_ins BEFORE INSERT ON btreehash FOR EACH ROW BEGIN SET NEW.url_crc=crc32(NEW.url);
END;
//

CREATE TRIGGER btreehash_crc_upd BEFORE UPDATE ON btreehash FOR EACH ROW BEGIN SET NEW.url_crc=crc32(NEW.url);
END;
//

DELIMITER ;
```
创建测试数据
```sql
INSERT INTO btreehash (url) VALUES ('http://www.mysql.com')
```
数据如下

id | url | url_crc
---------|----------|---------
 1 | http://www.mysql.com | 1560514994

这时我们用如下查询语句查询
```sql
SELECT id, url FROM btreehash WHERE url_crc = crc32('http://www.mysql.com') AND url = 'http://www.mysql.com';
```
由于`url_crc`是个整型值，会比字符串的查找效率更高，而且存储的数据更少。

这里需要注意的是查询条件中记得带上url字段，否则有可能因为哈希冲突查找到多行数据。

## 聚集索引和非聚集索引
### 聚集索引（聚簇索引）
数据行的物理顺序（存储在磁盘的顺序）和某一列（一般是主键那一列）的逻辑顺序相同，一个表中只能有一个聚集索引。

也就是说如果有某一列采用了聚集索引，那么该列是可以排序的，并且决定了表的排序顺序，从而决定了在物理存储中的存储顺序，也因此一张表中只能有一个聚集索引。

举个栗子：  
一张表就好比新华字典，聚集索引就像是拼音目录（A-Z排序），每个字存放的页码就是数据的物理地址。  
当我们需要查找一个“我”字时，会去拼音目录查找`wo`所在的页码，便可以定位到“我”字所在的位置。也就是说，拼音目录对应的A-Z的顺序，和实际文字的顺序是一样的，也就是说索引的顺序决定了物理存储的顺序。

在mysql的表中，主键就是聚集索引，如果没有主键，则会选择一个唯一的非空索引代替，如果没有这样的索引，InnoDB会隐式定义一个主键来作为聚集索引。

一般在建表的时候就会创建聚集索引。如果表中已经有大量数据，这时再创建聚集索引，由于数据需要重新进行排列，这个过程将会十分耗时。

```sql
CREATE TABLE t (
  id INT PRIMARY KEY,
  name VARCHAR(255)
)
```
上述sql创建了一个t表，由于id是主键，因此数据库将会自动在该表上的id字段建立聚集索引

### 非聚集索引
非聚集索引中，数据行的物理顺序和索引的逻辑顺序是不同的，因此一个表中可以有多个非聚集索引。

举个栗子：  
例如新华字典中可以按照偏旁来查找文字，偏旁就是索引，偏旁的顺序，也就是索引的顺序，但是它和文字的顺序是不一样的，偏旁需要记录文字的拼音所在的页码，通过该页码能够找到文字的位置。

非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。

假设有如下表
```sql
CREATE TABLE t (
  id INT PRIMARY KEY,
  name VARCHAR(255),
  dob DATE NOT NULL,
  KEY(name)
)
```
其中id是聚集索引，name是非聚集索引。此时如果进行如下查询都是可以直接通过索引获取到数据
```sql
SELECT id FROM t WHERE name = 'hello';
SELECT name FROM t WHERE name = 'hello';
SELECT id, name FROM t WHERE name = 'hello';
```

但是如果是下面的sql
```sql
SELECT dob FROM t WHERE name = 'hello';
```
上述sql需要二次的查询去获取原数据行的dob

也就是说，非聚集索引其实叶子节点除了会存储索引覆盖列的数据，也会存放聚集索引所覆盖的列数据。

这时候可以采用复合索引，将(name, dob)作为非聚合索引，这样便可以不需要获取原数据行了。但是需要注意的就是，联合索引会受最左前缀影响，这个在之前介绍B-Tree中介绍索引时已经讲了。

聚集索引和非聚集索引总结：
1. 聚集索引的查询效率会比非聚集索引高，，但是写入的性能不高，因为数据在磁盘中排好序存储的，如果新插入数据，则需要移动后面的数据
2. 非聚集索引可以采用联合索引的方式，这样性能也会很高
3. 小数据量的表不要建立索引

## 全文索引
todo...

参考资料:
1. [SQL中的索引](https://zhuanlan.zhihu.com/p/33222651)
1. [聚集索引与非聚集索引的总结](https://www.cnblogs.com/s-b-b/p/8334593.html)