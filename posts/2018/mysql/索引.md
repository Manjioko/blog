# 索引
索引是在存储引擎层实现的，不同的存储引擎的索引的工作方式也不一样，也不是所有的存储引擎都支持所有类型的索引，即使多个存储引擎支持同一种类型的索引，底层实现方式也可能不一样。

## B-Tree索引
mysql中的索引采用的是B-Tree这种数据结构来存储数据，因此采用索引查找的时候会有最左前缀的限制，即与创建表时定义索引的顺序有关。

```sql
CREATE TABLE People (
  last_name VARCHAR(50) NOT NULL,
  first_name VARCHAR(50) NOT NULL,
  dob DATE NOT NULL,
  gender ENUM('m', 'f') NOT NULL,
  KEY(last_name, first_name, dob)
)
```
上述sql语句指定了一个联合索引（last_name, first_name, dob）。

接下来分情况讨论

### 全值匹配
当你的查询语句中查询条件包含这三个索引字段时，mysql就能使用索引
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name='Cuba' And dob='1991-10-21';
```
该sql能够有效利用mysql索引。

如果把sql稍微改变下
```sql
SELECT * FROM People WHERE first_name='Cuba' And dob='1991-10-21' AND last_name='Allen' ;
```
这里查询条件中索引字段的顺序被调换了位置，是否依旧能够利用索引进行查询呢？  
答案是可以的，mysql中对这种情况有进行优化过。

### 匹配最左前缀
当只使用部分索引字段时，必须按照索引顺序来使用，如下面的sql只使用了第一列：
```sql
SELECT * FROM People WHERE last_name='Allen';
```
也可以使用索引前两列：
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name='Cube';
```

如果查询时没有按照索引的顺序来使用，或者跳过了第一个索引字段，则不满足最左前缀，例如下面的语句都是无法使用索引：
```sql
SELECT * FROM People WHERE first_name='Cuba';
SELECT * FROM People WHERE dob='1991-10-21';
SELECT * FROM People WHERE first_name='Cuba' AND dob='1991-10-21';
SELECT * FROM People WHERE last_name='Allen' AND dob='1991-10-21';
```

### 匹配列前缀
可以只匹配某一列的值的开头部分，例如以`Al`开头的last_name；
```sql
SELECT * FROM People WHERE last_name LIKE 'Al%';
```
但是如果是模糊匹配以`len`结尾则无法使用索引，如下面的sql：
```sql
SELECT * FROM People WHERE last_name LIKE '%len';
```
同最左前缀一样，这里也只能使用第一列进行模糊匹配，如下面这条sql就无法利用first_name的索引。
```sql
SELECT * FROM People WHERE first_name LIKE 'Cu%';
```

### 匹配范围值
例如可以查找last_name在`Allen`和`Mike`的人。
```sql
SELECT * FROM People WHERE last_name='Allen' OR last_name='Mike';
```

### 精确匹配某一列并范围匹配另外一列
查询语句中可以有精确匹配，也可以有模糊匹配
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name LIKE 'Cu%';
```
但是此时，如果还是用了dob作为查询条件，是无法使用dob的索引的。  
换句话说，即如果查询有某个列的范围查询，则其右边的所有列都无法使用索引优化查找。
```sql
SELECT * FROM People WHERE last_name='Allen' AND first_name LIKE 'Cu%' AND dob = '1991-10-21';
```

以上列出了几种查询情况能够使用索引的方式，当然这些不仅是在`WHERE`子句中生效，在`ORDER BY`只要满足上述查询方式，索引依旧有效。

## 哈希索引
哈希索引是基于哈希表实现的，只有精确匹配索引所有列的的查询才能有效。存储引擎会对所有索引列计算一个哈希码，它是一个较小的值。然后引擎会维护一个哈希表，key为之前计算的哈希值，value是对应行的指针。

在查找数据时候，先计算列对应的哈希值，通过哈希表找到行指针，还要对比行指针中列的数据是否是之前指定的数据。

在mysql中，只有Memory引擎显示支持哈希索引，也是它的默认索引，但是它也支持b-tree索引。  
另外，Memory引擎支持非唯一哈希索引，如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。

```sql
CREATE TABLE testhash (
  fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  KEY USING HASH(fname) 
) ENGINE=MEMORY
```
网数据库中插入几条测试数据

fname | lname 
---------|----------
 A1 | B1 
 A2 | B2 
 A3 | B3 
 A4 | B4

引擎中的哈希函数，假设为hash()，可能会有如下值返回
```
hash('A1') = 2323
hash('A2') = 7437
hash('A3') = 8784
hash('A4') = 2458
hash('A5') = 2458
```

这时哈希引擎维护了如下这样一张哈希表：

槽（slot） | 值（value）
---------|----------
 2323 | 指向第1行的指针
 2458 | 指向第4行的指针 --> 指向第5行的指针
 7437 | 指向第2行的指针
 8784 | 指向第3行的指针

这时如果你的sql如下
```sql
SELECT * FROM testhash WHERE fname='A3';
```
这时将fname哈希后值为8784，通过哈希表知道它`指向第3行的指针`，故能快速定位到表的第3行中，这个是常数时间。

虽然哈希索引很快，但是也有一些弊端
1. 由于采用的是将索引字段哈希，故无法用于排序
2. 哈希索引只包含哈希值和行指针，而不存储字段值，无法使用索引中的值来避免读取行
3. 哈希索引不支持部分索引匹配查找，因为哈希索引始终使用索引列的全部内容来计算哈希。因此如果在数据列(A,B)上建立哈希索引，如果只查询数据列A，则无法使用该索引。
4. 哈希索引只支持等值比较查询
5. 当出现哈希值冲突时，底层采用了链表来存储所有的行指针，此时需要逐个遍历行指针。例如上面示例中A5的哈希值和A4一样，则哈希表会维护一个链表，遍历后能够知道A5在第5行。
6. 哈希冲突很多的话，对数据的删除很不利。因为每次删除数据，需要逐个遍历链表找到对应的行，删除对应行的引用。

鉴于以上弊端，我们很少直接使用哈希索引。如果我们既想使用哈希索引高效的查找速度，也想拥有B-Tree索引的特性（如：排序、部分列查找）该怎么办。这时我们可以在B-Tree基础上创建一个伪哈希索引

### B-Tree和哈希索引结合
有这样一个场景，假设我们经常需要通过一个url来查询，而由于url本身很长，索引存储的内容很大，性能上会不大好，如果我们增加一个url_crc的列，它是个整型值，值来自于url的crc32值，由于crc32的值都会比较短，性能上能够得到提高。

```sql
CREATE TABLE btreehash (
  id INT UNSIGNED NOT NULL auto_increment,
  url VARCHAR(255) NOT NULL,
  url_crc INT UNSIGNED NOT NULL DEFAULT 0,
  PRIMARY KEY(id)
)
```

接下来创建一个触发器，在每次写入和更新的时候都自动计算url_crc值
```SQL
DELIMITER //

CREATE TRIGGER btreehash_crc_ins BEFORE INSERT ON btreehash FOR EACH ROW BEGIN SET NEW.url_crc=crc32(NEW.url);
END;
//

CREATE TRIGGER btreehash_crc_upd BEFORE UPDATE ON btreehash FOR EACH ROW BEGIN SET NEW.url_crc=crc32(NEW.url);
END;
//

DELIMITER ;
```
创建测试数据
```sql
INSERT INTO btreehash (url) VALUES ('http://www.mysql.com')
```
数据如下

id | url | url_crc
---------|----------|---------
 1 | http://www.mysql.com | 1560514994

这时我们用如下查询语句查询
```sql
SELECT id, url FROM btreehash WHERE url_crc = crc32('http://www.mysql.com') AND url = 'http://www.mysql.com';
```
由于`url_crc`是个整型值，会比字符串的查找效率更高，而且存储的数据更少。

这里需要注意的是查询条件中记得带上url字段，否则有可能因为哈希冲突查找到多行数据。

## 全文索引
todo...

参考资料:
1. [SQL中的索引](https://zhuanlan.zhihu.com/p/33222651)