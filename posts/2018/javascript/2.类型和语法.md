# 基本类型
javascript有如下基本类型：
* string
* number
* boolean
* null
* undefined
* object
* symbol (es6新增)

javascript是动态语言，它的变量可以被指定为任意类型的值，可以使用typeof来获取值的基本类型
```javascript
typeof 'abc' // string
typeof 123 // number
typeof true // boolean
typeof {a: 1} // object
```

然而有几个类型却是需要特别注意的：
```javascript
typeof null // object
typeof function a () {} // function
```
此处可见`null`的类型竟然是object，这个也是历史原因了，无法被修复  
而function是object的子类型

## 关于undefined
我们知道当一个变量被声明后，没有被赋值则会被定义为undefined
```javascript
var a
typeof a // undefined

typeof b // undefined
console.log(b) // ReferenceError: b is not defined
```
上述代码a可以理解，但是b没有被声明也是undefined就比较困惑了，但是在console.log中使用b时却会报错。

# 数值
javascript没有所谓的整数，所有的数字类型都是浮点数，采用的是“双精度浮点数”（即64位二进制）。这是根据IEEE754双精度浮点数定义出来的。  
简单来说，javascript中的整数就是没有小数的十进制数，即42.0等同于“整数”42。

二进制浮点数最大的问题就是在做数值运算的时候会有差错
```javascript
0.1 + 0.2 === 0.3 // false
```
实际上该值是0.30000000000000004，条件判断结果为false。

我们只能通过设置一个范围值来判断，该范围值即为“机器精度”，对于javascript来说就是2^-52（2.220446049250313e-16）
```javascript
var a = 0.1 + 0.2
var b = 0.3
Math.abs(a - b) < Number.EPSILON  // true 
```

最大的浮点数大约是1.798e+308，即Number.MAX_VALUE;  
最小的浮点数大约是5e-324，即Number.MIN_VALUE，该值无限接近0;  

## 安全整数
安全是指在（-2^53, 2^53）范围内，双精度数表示和整数是一对一的，反过来说，在这个范围内，所有的整数都有唯一的浮点数表示，这就是安全整数。

能够被安全呈现的最大整数是2^53 - 1，即即9007199254740991，在ES6中被定义为Number.MAX_SAFE_INTEGER;  
最小整数是-9007199254740991，即Number.MIN_SAFE_INTEGER。

具体可以参考下 [javascript 里最大的安全的整数为什么是2的53次方减一？](https://www.zhihu.com/question/29010688)

检测一个数是不是安全整数
```javascript
Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true
Number.isSafeInteger(Math.pow( 2, 53 )) // false
```

## NaN（not a number）
如果进行数值运算后的值不是数字，则会返回NaN。
```javascript
var a = 2 / 'foo' // NaN
typeof a === 'number' // true
```
很明显，NaN的类型也被认为是数值类型，就是说不是数字的数字，仍然是数字类型，确实有点神奇。

NaN是唯一一个与自身不相等的值
```javascript
var a = 2 / 'foo'
a == NaN // false
a === NaN // false
```

ES6增加了一个判断是不是NaN的工具函数
```javascript
Number.isNaN(NaN) // true
```

我们也可以自己实现一个
```javascript
// 方法一
Number.isNaN = function (n) {
  return (
    typeof n === 'number' && window.isNaN(n)
  )
}

// 方法二
Number.isNaN = function (n) {
  return n !== n
}
```
注意window.isNaN()会将所有非数值类型都认为是NaN，即`window.isNaN('num')`会是NaN，所以方法一中会先判断参数的类型是否是number类型。

# Symbol
ES6引入了第七种基本类型symbol，代表第一无二的值。

考虑以下场景，如果有个工具，会根据你传入的类型产生指定的对象。
```javascript
const animal = {
  DOG: 'dogdogdogdogdogdogdogdog',
  CAT: 'catcatcatcatcatcatcatcat'
}

function createObject (type) {
  let animal = null
  switch (type) {
    case animal.DOG:
      animal = createDog()
      break;
    case animal.CAT
      animal = createCat()
    default:
      break;
  }
  return animal
}

const cat = createObject(animal.CAT)
```
我们发现，虽然createObject函数的参数需要type，但是它的值具体是什么对我们来说并不重要，只需要它和animal.DOG或者animal.CAT相等就可以了，同时也只是需要animal.DOG或者animal.CAT不相等即可。

这时symbol就可以发挥作用了
```javascript
const animal = {
  DOG: Symbol(),
  CAT: Symbol()
}

animal.DOG !== animal.CAT // true
typeof animal.DOG // symbol
animal.DOG.toString() // Symbol()
```
同时我们还可以为Symbol取一个名字，类似于备注一样
```javascript
const animal = {
  DOG: Symbol('dog'),
  CAT: Symbol('cat')
}

animal.DOG !== animal.CAT // true
typeof animal.DOG // symbol
animal.DOG.toString() // Symbol(dog)
```

即使相同名字的symbol，也是不同的symbol对象
```javascript
var s1 = Symbol('s')
var s2 = Symbol('s')

s1 === s2 // false
```

使用symbol作为属性名或者值时，有几点需要注意：  
1. 该属性不会出现在`for...in`、`for...of`循环中
2. 不会被`Object.keys()`、`Object.getOwnPropertyNames()`、`JSON.stringify()`返回
3. 它不是个私有属性
4. 采用Object.getOwnPropertySymbols()可以获取对象的所有symbol属性名